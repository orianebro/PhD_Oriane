[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PhD Oriane",
    "section": "",
    "text": "Preface\nThis book keeps track of the work made during the PhD of Oriane Braud, entitled “Multiscale hybrid modeling framework for intercrops: the best of plant and crop models”. This PhD is carried out from November 2023 to 2026 at CIRAD (UMRs AGAP and AMAP), as part of European project IntercropValuES, and is supervised by Myriam Adam, Marc Jaeger, Christophe Pradal, Remi Vezy and Thomas Arsouze.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "abstract.html",
    "href": "abstract.html",
    "title": "Abstract",
    "section": "",
    "text": "1. Concevoir un FSPM contraint par un modèle de culture pour les cultures intercalaires\nUn FSPM dynamique paramétrique, aérien et racinaire, adapté pour les céréales et les légumineuses, et visant à être contraint par les sorties d’un modèle de culture (par exemple, reconstruire la croissance et le développement d’une plante à partir du LAI et de la hauteur du couvert pour la partie aérienne) est en cours de création.\nCela laisse autant de degrés de liberté que la structure 3D implémentée dans le modèle le permet, et donc une variabilité architecturale aussi grande qu’il y a de paramètres architecturaux. En somme, le but est de pouvoir représenter un modèle de culture avec une structure 3D et un arrangement spatial explicite des cultures intercalaires.\nRéalisation : modèle FSPM",
    "crumbs": [
      "Abstract"
    ]
  },
  {
    "objectID": "abstract.html#identifier-les-processus-perfectibles-des-modèles-de-culture",
    "href": "abstract.html#identifier-les-processus-perfectibles-des-modèles-de-culture",
    "title": "Abstract",
    "section": "2. Identifier les processus perfectibles des modèles de culture",
    "text": "2. Identifier les processus perfectibles des modèles de culture\nEn utilisant le FSPM précédemment créé, il sera possible, pour une simulation avec un modèle de culture, d’en obtenir un grand nombre en explorant un espace phénotypique défini pour chaque espèce par les paramètres architecturaux non pris en compte dans le modèle de culture, ainsi qu’en modifiant l’arrangement spatial explicite des cultures intercalaires. Une vaste expérience de simulation sera réalisée pour comprendre comment les différents processus (interception de la lumière, absorption de l’eau et de l’azote, etc.) sont modifiés en fonction des variations des caractéristiques architecturales des plantes, de l’arrangement spatial des cultures intercalaires, mais aussi en tenant compte de l’échelle spatiale et temporelle des processus simulés.\nDes analyses statistiques (comparaison de moyennes, analyse de la variance, de propagation d’incertitude, de sensibilité) seront faites sur les sorties de ces simulations pour identifier les processus pour lesquels la prise en compte d’échelles plus fines a une influence, ainsi que des paramètres d’intérêt.\nLes espèces et variétés de plantes utilisées pour simuler les cultures intercalaires seront choisies en fonction de la paramétrisation existante de STICS pour les cultures intercalaires, ainsi que des expériences disponibles dans le projet IntercropValuES.\nRéalisation : méthodologie + application avec STICS",
    "crumbs": [
      "Abstract"
    ]
  },
  {
    "objectID": "abstract.html#tester-différentes-approches-pour-améliorer-la-prise-en-compte-des-paramètres-structuraux-dintérêt-pour-la-modélisation-des-cultures-intercalaires-dans-les-formalismes-du-modèle-de-culture-stics-intercrop-avec-une-approche-multi-échelle",
    "href": "abstract.html#tester-différentes-approches-pour-améliorer-la-prise-en-compte-des-paramètres-structuraux-dintérêt-pour-la-modélisation-des-cultures-intercalaires-dans-les-formalismes-du-modèle-de-culture-stics-intercrop-avec-une-approche-multi-échelle",
    "title": "Abstract",
    "section": "3. Tester différentes approches pour améliorer la prise en compte des paramètres structuraux d’intérêt pour la modélisation des cultures intercalaires dans les formalismes du modèle de culture STICS-Intercrop avec une approche multi-échelle",
    "text": "3. Tester différentes approches pour améliorer la prise en compte des paramètres structuraux d’intérêt pour la modélisation des cultures intercalaires dans les formalismes du modèle de culture STICS-Intercrop avec une approche multi-échelle\nLes processus identifiés précédemment seront étudiés à différentes échelles spatiales et temporelles. Pour passer d’une échelle (par exemple l’échelle de l’organe) à une autre (par exemple l’échelle de la culture), plusieurs stratégies seront étudiées : comment trouver un modèle analytique équivalent pour l’absorption d’eau en utilisant des hypothèses homogènes (Couveur et al., 2012) ? Comment estimer un modèle de substitution basé sur la sortie du modèle à une échelle plus fine pour capturer les propriétés émergentes ? Ou encore, comment concevoir des modèles hybrides en combinant des modules existants à la même échelle ou à des échelles différentes ?\nCela conduira à de nouveaux formalismes dans le modèle de culture.\nRéalisation : nouveaux formalismes pour la prochaine version de STICS",
    "crumbs": [
      "Abstract"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "In progress …\nTalk about intercropping as an agro-ecological practice, the barriers, the importance of modeling, the existing models (crop and FSPM) and their characteristics, their limits as for modeling intercrops, focus on evaluating how hypotheses in crop models are off the mark, for processes occuring in shoot and root, and how to modify the formalisms corresping to processes that are off the mark in STICS crop model in particular.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "year_1.html",
    "href": "year_1.html",
    "title": "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
    "section": "",
    "text": "Analysis - shoot: Does considering plant shoot structural variability change a crop model’s outputs in an intercropping context ?\nHypothesis: The error of crop models, when it comes to modeling intercrops, are mainly due to the average plant hypothesis and the non-consideration of the plant shoot architecture.\nIs the variability generated by structural considerations large enough to unvalidate crop model hypotheses ?\nWhat is the sensitivity of intercrops to variations of plant structure (and spatial arrangement) ?\nHow do the uncertainties linked to crop model hypotheses propagate when considering plant structure ?\nDevelop a dynamic shoot parametric FSPM for each type of plant (cereals and legumes, inspiration from OpenAlea models Cereal, L-Pea, WeberPenn, etc., to adapt for intercrops for which we have data), where growth is constrained by outputs from a crop model (e.g. LAI(t) and height(t)), leaving degrees of freedom for features that are not explicitly considered in the crop model (e.g. plant architecture and spatial arrangement).\nImplement well-known structural reactions to stresses.\nRun simulations of various GxGxExM with both FSPM and STICS (stressless and stressed conditions : Vezy et al., 2023; Traore et al., 2022, 2023), varying (define variations ranges) when possible: shoot structures (explore phenotypic space, i.e. create many morphotypes), spatial arrangement (with all same plants or all different to separate effects), env/stresses (N, water, light)\nFrom outputs from my models and from STICS for given processes and given conditions:\n- Compare means and analyze variance of chosen output variables: light intercepted, RUE, N demand /organ, etc.\n- Analyse uncertainty propagation in simulations. Expected results: see which processes are the most impacted by the uncertainty in crop model outputs.\n- Analyse sensitivity of some plant processes to structural variability and spatial heterogeneity. Expected results: spot parameters of interest that can make a change if better considered in a crop model when modeling intercrops.\nUnvalidate some formalisms in STICS",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability"
    ]
  },
  {
    "objectID": "intro_1.html",
    "href": "intro_1.html",
    "title": "2  Introduction",
    "section": "",
    "text": "In progress …",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html",
    "href": "structural_cereal_model.html",
    "title": "3  Structural cereal model",
    "section": "",
    "text": "3.1 Create a parametric leaf\nReviewNB link: https://app.reviewnb.com/orianebro/PhD_Oriane/blob/main/structural_cereal_model.ipynb\nIn this section, we define a static structural model for cereals.\nThe paragraphs are organized so that it is easy to see how the model is built and how we can play with parameters.\nSome 3D plots are interactive, don’t hesitate to rotate them.\nThe leaf blade is represented as a surface.\nA parametric leaf is here defined by sample points (here 12), described by two sets of coordinates:\n- \\((x,y)\\): coordinates for the midrib in a vertical plane, give the curvature of the leaf;\n- \\((s,r)\\): curviliear abcissa (i.e. length along midrib) and relative length-dependent leaf width.\nNote that \\(s\\) can be expressed as a function of \\(x\\) and \\(y\\), at point \\(p \\neq 0\\), as follows: $ s_p(x,y) = $.\nThe origin represents the leaf base.\nCode\n## Imports\n\n# from installed packages\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom heapq import *\nfrom scipy.interpolate import splprep, splev\nfrom scipy.integrate import simps, trapz\nfrom openalea.plantgl.all import Vector3\n\n# from openalea.openalea.archicrop\nfrom openalea.archicrop.cereals_leaf import leaf_shape_perez, sr_prevot, parametric_leaf\n# or\n# from openalea.openalea.archicrop.simple_maize import leaf_shape_perez, sr_prevot, parametric_leaf\n# from openalea.openalea.archicrop.fitting import leaf_shape_perez\nfrom openalea.archicrop.generator import curvilinear_abscisse\nfrom openalea.archicrop.fitting import fit2, fit3, simplify\nfrom openalea.archicrop.simplification import distance, cost\n\n## Code for generating a parametric leaf for a cereal \npl=parametric_leaf(nb_segment=10, insertion_angle=40, scurv=0.7, curvature=70, alpha=-2.3)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2) \n# fig.suptitle('Parametric leaf')\n\nax1.plot(pl[0], pl[1], '.-', c=\"green\")\nax1.set_xlabel('x')\nax1.set_ylabel('y')\nax1.set_title(\"Coordinates of the midrib in a vertical plane\")\n\nax2.plot(pl[2], pl[3], '-', c=\"green\")\nax2.plot(pl[2], -pl[3], '-', c=\"green\")\nax2.plot(np.arange(0,1.1,0.1), np.zeros(11), c=\"green\", ls=\"dashed\")\nax2.set_xlabel('s')\nax2.set_ylabel('r')\nax2.set_title(\"Flattened leaf shape\")\n\nplt.subplots_adjust(hspace=0.5)\n\nplt.show()\nCode\n## Imports\n\n# from installed packages\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom scipy.interpolate import interp2d\nimport matplotlib.tri as mtri\n\n# from openalea.archicrop\nfrom openalea.archicrop.fitting import leaf_to_mesh_2d\n\n## Code for representing the parametric leaf in 3D (ignore excess lines)\nx=pl[0]\ny=pl[1]\ns=pl[2]\nr=pl[3]\n\npts,ind=leaf_to_mesh_2d(x, y, r)\n\nxs=[pt[0] for pt in pts]\nys=[pt[1] for pt in pts]\nzs=[pt[2] for pt in pts]\n    \nX,Y=np.meshgrid(xs, ys)\n\ntri=mtri.Triangulation(xs, ys)\n\nfig=plt.figure()\nax=fig.add_subplot(111, projection='3d')\nax.scatter(xs,ys,zs,c=\"green\")\nax.plot(xs,ys,zs,c=\"green\")\nax.plot(xs,np.zeros(len(ys)),zs,c=\"green\",ls=\"dashed\")\nax.set_title(\"3D representation of a leaf shape with curvature\")\nplt.show()\nPlease ignore excess straight lines.\nCode\n# from openalea.archicrop\nfrom openalea.archicrop.cereals_leaf import parametric_leaf\nfrom openalea.archicrop.geometry import leaf_mesh_for_growth, stem_mesh\n\ndef simple_leaf(leaf, ratio):\n    total_length = 80\n    lw_ratio = 7.0\n\n    L_shape = total_length\n    Lw_shape = total_length / lw_ratio\n    length = total_length * ratio\n    s_base = 0\n    s_top = 1.0\n\n    return leaf_mesh_for_growth(leaf, L_shape, Lw_shape, length, s_base, s_top)\nCode\nimport matplotlib.pyplot as plt\nfrom openalea.plantgl.all import Vector3\nfrom oawidgets.plantgl import *\n\n# leaf = parametric_leaf(insertion_angle=30, scurv=0.6, curvature=130, alpha=-2.3)\nleaf = parametric_leaf(insertion_angle=45, scurv=0.7, curvature=90, alpha=-2.3)\nmesh = simple_leaf(leaf, 1) \n\nPlantGL(mesh)\n\n# 326400",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#generate-leaf-azimuth-series",
    "href": "structural_cereal_model.html#generate-leaf-azimuth-series",
    "title": "3  Structural cereal model",
    "section": "3.2 Generate leaf azimuth series",
    "text": "3.2 Generate leaf azimuth series\nLeaves grow around an axis with a given phyllotaxy, represented here as an angle from leaf to leaf (e.g. spiral with a given angle or alternate distichous = \\(180^o\\)).\n\n\nCode\n## Imports\n\n# from installed packages \n# from itertools import cycle\n\n# from openalea.archicrop\nfrom openalea.archicrop.plant_design import leaf_azimuth\n\n## Code for generating leaf azimuths series for a given phyllotaxy\nnb_phy=10\nphyllotactic_angle=137\nspiral=True\nphyllotactic_deviation=0\nplant_orientation=0\n\nla=leaf_azimuth(size=nb_phy, \n                phyllotactic_angle=phyllotactic_angle, \n                phyllotactic_deviation=phyllotactic_deviation, \n                plant_orientation=plant_orientation, \n                spiral=spiral)\n\nx=np.cos(la*np.pi/180)\ny=np.sin(la*np.pi/180)\nz=np.linspace(1,len(la)+1,len(la))\n\nfig,ax=plt.subplots(subplot_kw=dict(projection='3d'))\nfor i,a in enumerate(la):\n    ax.plot(np.linspace(0,x[i],2), np.linspace(0,y[i],2), [z[i],z[i]], c=\"green\")\nax.plot([0,0], [0,0], [0,z[-1]], c=\"green\")\n\nax.set_title(\"3D representation of phyllotaxy\")\n\nplt.show()",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#manage-internode-lengths",
    "href": "structural_cereal_model.html#manage-internode-lengths",
    "title": "3  Structural cereal model",
    "section": "3.3 Manage internode lengths",
    "text": "3.3 Manage internode lengths\nInternodes on an axis have varying lengths. The repartition of their lengths along the axis can be approximated with a geometric model.\n\n\nCode\n## Imports\nfrom openalea.archicrop.plant_shape import geometric_dist\n\n## Code for applying lengths to internodes according to a geometric model\nplant_height=15\nq=1.5\n\nx=np.cos(la*np.pi/180)\ny=np.sin(la*np.pi/180)\nz=geometric_dist(height=plant_height, \n                   nb_phy=nb_phy, \n                   q=q)\n\nfig,ax=plt.subplots(subplot_kw=dict(projection='3d'))\nfor i,a in enumerate(la):\n    ax.plot(np.linspace(0,x[i],2), np.linspace(0,y[i],2), [z[i],z[i]], c=\"green\")\nax.plot([0,0], [0,0], [0,z[-1]], c=\"green\")\n\nax.set_title(\"3D representation of the repartition of internode length along the stem\")\n\nplt.show()\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[9], line 10\n      8 x=np.cos(la*np.pi/180)\n      9 y=np.sin(la*np.pi/180)\n---&gt; 10 z=geometric_dist(height=plant_height, \n     11                    nb_phy=nb_phy, \n     12                    q=q)\n     14 fig,ax=plt.subplots(subplot_kw=dict(projection='3d'))\n     15 for i,a in enumerate(la):\n\nTypeError: geometric_dist() missing 1 required positional argument: 'u0'\n\n\n\n\n\nCode\nfrom openalea.archicrop.plant_shape import collar_heights_kaitaniemi, geometric_dist\n\nnb_phy = 10\nheight = 100\n\ncollar_heights = collar_heights_kaitaniemi(height, nb_phy)\nprint(collar_heights)\n\ncollar_heights_geom = geometric_dist(height, nb_phy, 1.1)\n\nplt.plot(range(nb_phy), collar_heights)\nplt.plot(range(nb_phy), collar_heights_geom)\nplt.scatter(range(nb_phy), collar_heights_geom)\nplt.show()",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#manage-leaf-lengths-as-a-function-of-height",
    "href": "structural_cereal_model.html#manage-leaf-lengths-as-a-function-of-height",
    "title": "3  Structural cereal model",
    "section": "3.4 Manage leaf lengths as a function of height",
    "text": "3.4 Manage leaf lengths as a function of height\nLeaves that grow on an axis have varying lengths. The repartition of their lengths along the axis can be approximated with a bell shaped model.\n\n\nCode\n## Imports\nfrom openalea.archicrop.plant_shape import bell_shaped_dist\n\n## Code for applying lengths to leaves according to a bell shaped model\nmax_leaf_length=50\n\nbsd=bell_shaped_dist(max_leaf_length=max_leaf_length, \n                     nb_phy=nb_phy, \n                     rmax=.8, \n                     skew=0.15)\n\nx=np.cos(la*np.pi/180)*bsd\ny=np.sin(la*np.pi/180)*bsd\nz=geometric_dist(height=plant_height, \n                   nb_phy=nb_phy, \n                   q=q)\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nfor i,a in enumerate(la):\n    ax.plot(np.linspace(0,x[i],2), np.linspace(0,y[i],2), [z[i],z[i]], c=\"green\")\nax.plot([0,0], [0,0], [0,z[-1]], c=\"green\")\n\nax.set_title(\"3D representation of the repartition of leaf length along the stem\")\n\nplt.show()\n\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[10], line 14\n     12 x=np.cos(la*np.pi/180)*bsd\n     13 y=np.sin(la*np.pi/180)*bsd\n---&gt; 14 z=geometric_dist(height=plant_height, \n     15                    nb_phy=nb_phy, \n     16                    q=q)\n     18 fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\n     19 for i,a in enumerate(la):\n\nTypeError: geometric_dist() missing 1 required positional argument: 'u0'\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\n\n# from openalea.archicrop.plant_shape import bell_shaped_dist\n\ndef bell_shaped_dist(max_leaf_length, nb_phy, rmax, skew):\n    \"\"\"returns leaf area of individual leaves along bell shaped model\"\"\"\n    k = -np.log(skew) * rmax\n    r = np.linspace(1.0 / nb_phy, 1, nb_phy)\n    relative_length = np.exp(-k / rmax * (2 * (r - rmax) ** 2 + (r - rmax) ** 3))\n    # leaf_length = relative_length / relative_length.sum() * 100 --&gt; percentage of total leaf lengths --&gt; same for areas\n    leaf_length = relative_length * max_leaf_length\n    return leaf_length.tolist()\n    \n\nmax_leaf_length = 1\nnb_phy = 22\nrmax = 0.66\nskew = 0.05\nfor skew in np.arange(0.01, 0.1, 0.01):\n    leaf_lengths = bell_shaped_dist(max_leaf_length, nb_phy, rmax, skew)\n    plt.plot(range(len(leaf_lengths)), leaf_lengths)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\nfrom openalea.archicrop.cereals_leaf import sr_prevot\n\ndef normalized_leaf_area_distribution(leaf_lengths, wl):\n    leaf_areas = []\n    for L in leaf_lengths:\n        leaf_areas.append(2*0.749908422143643*wl*L**2)\n    # Normalize the leaf_areas so their sum equals 1\n    total_area = sum(leaf_areas)\n    normalized_leaf_areas = [area / total_area for area in leaf_areas]\n    return normalized_leaf_areas\n\nleaf_lengths = bell_shaped_dist(max_leaf_length=1, nb_phy=22, rmax=0.67, skew=0.1)\nwl = 0.12\n\nleaf_areas = normalized_leaf_area_distribution(leaf_lengths, wl)\nplt.plot(range(len(leaf_areas)), leaf_areas)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n1.51657508881031-0.766666666666667\n\n\n0.749908422143643\n\n\n\n\nCode\n2*0.749908422143643\n\n\n1.499816844287286",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#arrange-a-leaf-to-be-placed-along-a-stem-with-a-given-inclination.",
    "href": "structural_cereal_model.html#arrange-a-leaf-to-be-placed-along-a-stem-with-a-given-inclination.",
    "title": "3  Structural cereal model",
    "section": "3.5 Arrange a leaf to be placed along a stem with a given inclination.",
    "text": "3.5 Arrange a leaf to be placed along a stem with a given inclination.\nA leaf must undergo a translation to be placed against the surface of the stem (tangent to it), and a rotation to be tilted like the stem (inclination = 1 if main stem).\n\n\nCode\n## Imports\n\n# from installed packages\nfrom math import pi, cos, sin, radians\nimport openalea.plantgl.all as pgl\n\n# from openalea.archicrop\n# from openalea.archicrop.cereals_leaf import arrange_leaf\n# or \nfrom openalea.archicrop.geometry import arrange_leaf\n\n## Code for placing a leaf against a stem element (here a cylinder), with a given inclination\nstem_diameter=0.5\ninclination=1\n\nal=arrange_leaf(leaf=pl, \n                stem_diameter=stem_diameter, \n                inclination=inclination, \n                relative=True)\n\nx=al[0]\ny=al[1]\ns=al[2]\nr=al[3]\n\npts,ind=leaf_to_mesh_2d(x, y, r)\n\nxs=[pt[0] for pt in pts]\nys=[pt[1] for pt in pts]\nzs=[pt[2] for pt in pts]\n    \nX,Y=np.meshgrid(xs, ys)\n\ntri=mtri.Triangulation(xs, ys)\n\nfig=plt.figure()\nax=fig.add_subplot(111, projection='3d')\nax.plot(xs,ys,zs,c=\"green\")\nax.plot([xs[0],xs[0]],[ys[0],-ys[0]],[0,0],c=\"green\")\nax.plot(xs,np.zeros(len(ys)),zs,c=\"green\",ls=\"dashed\")\n\nradius=stem_diameter/2\nz=np.linspace(-zs[-1], zs[-1])\ntheta=np.linspace(0, 2*np.pi)\ntheta_grid, z_stem=np.meshgrid(theta, z)\nx_stem=radius*np.cos(theta_grid)\ny_stem=radius*np.sin(theta_grid)\n\nax.plot_surface(x_stem, y_stem, z_stem, color=\"green\")\n\nax.set_title(\"3D representation of the placement of a leaf along a stem\")\n\nplt.show()",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#build-the-whole-plant-shoot-in-3d-as-an-mtg.",
    "href": "structural_cereal_model.html#build-the-whole-plant-shoot-in-3d-as-an-mtg.",
    "title": "3  Structural cereal model",
    "section": "3.6 Build the whole plant shoot in 3D, as an MTG.",
    "text": "3.6 Build the whole plant shoot in 3D, as an MTG.\nAn MTG (Multiscale Tree Graph) is created as a representation of a parametrized cereal shoot.\nThe different scales are: - Plant\n- Axis\n- Stem / Leaf\n\n\nCode\n## Imports\n\n# from installed packages\nimport openalea.plantgl.all as pgl\nfrom openalea.mtg.turtle import TurtleFrame\nfrom openalea.mtg import MTG, fat_mtg\nfrom scipy.interpolate import interp1d\nimport pandas\n\n# from openalea.archicrop\nfrom openalea.archicrop.cereals import build_shoot",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#display-scenes-according-to-different-scenarii",
    "href": "structural_cereal_model.html#display-scenes-according-to-different-scenarii",
    "title": "3  Structural cereal model",
    "section": "3.7 Display scenes according to different scenarii",
    "text": "3.7 Display scenes according to different scenarii\n\n\nCode\n## Imports\n\n# from installed packages\nfrom oawidgets.plantgl import *\n\n# Set nice color for plants\nnice_green=Color3((50,100,0))\n\n\n\n3.7.1 A single cereal\n\n\nCode\n## Imports\n\n# from installed packages\nfrom oawidgets.plantgl import *\n\n# from openalea.archicrop\nfrom openalea.archicrop.display import display_mtg, build_scene, display_scene\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating a 3D cereal shoot from descritive parameters\n# Parameters \nheight=220                 \nnb_phy=22 # (15, 25, 35) # 22\nmax_leaf_length=90 # (60, 90, 120) # 90\n\n\n\n\n\nshoot, g = build_shoot(nb_phy=nb_phy,\n                        height=height,\n                        max_leaf_length=max_leaf_length,\n                        wl=0.12, # (0.1, 0.13) # 0.12\n                        diam_base=2.5, \n                        diam_top=0.5, \n                        insertion_angle=30, # (30, 60) # 30\n                        scurv=0.6, # (0.3, 0.6, 0.9) # 0.6\n                        curvature=135, # (0, 45, 90, 135) # 130\n                        alpha=-2.3, \n                        stem_q=1, # (1, 1.1)\n                        rmax=0.67, \n                        skew=0.05, # 0.0005\n                        phyllotactic_angle=180,\n                        phyllotactic_deviation=0)\n\n# Build and display scene\nscene, nump = build_scene(g, \n                                 leaf_material=Material(nice_green), \n                                 stem_material=Material(nice_green))\n# display_scene(scene_single) # display in separate window\nPlantGL(scene) # display in notebook\n\n\n\n\nCode\nfor id in g.vertices():\n    print(g[id])\n\n\nLet’s dig into the propreties of the MTG of a cereal shoot.\n\n\nCode\n## Imports\n\n# from installed packages\nfrom oawidgets.mtg import *\n\n\n## Code for exploring the MTG of the generated cereal shoot\n\n# Properties on the MTG: this exclude all the topological properties\nprint(g.property_names())\n\n# Retrieve one property for the MTG (dict)\n\nlabels = g.property('label')\n# print(labels)\n\ni_length = g.property('mature_length')\nl_length = g.property('mature_length')\n\nleaf_lengths=[]\nleaf_ind=[]\ninternode_lengths=[]\ninternode_ind=[]\nfor k,v in i_length.items():\n    internode_ind.append(k)\n    internode_lengths.append(v)\nfor k,v in l_length.items():\n    leaf_ind.append(k)\n    leaf_lengths.append(v)\n\n\n\nplt.figure()\nplt.plot(leaf_ind, leaf_lengths, c=\"green\", label=\"Leaf lengths\") # == 'shape_mature_length' for final plant\nplt.plot(internode_ind, internode_lengths, c=\"orange\", label=\"Internode lengths\")\nplt.plot(internode_ind, np.cumsum(internode_lengths), c=\"orange\", label=\"Plant height\", ls='--')\nplt.xlabel(\"Vertices\")\nplt.ylabel(\"Lengths (cm)\")\nplt.title(\"MTG properties\")\nplt.legend()\nplt.show()\n\n\nThe leaf lengths and widths follow the bell shaped curve described before.\nThe first internode in the MTG actually corresponds to the pseudostem, i.e. the about 4 to 8 short first internodes that rapidly lose their leaves. The lengths following internodes follow the geometric model described before.\n\n\n3.7.2 A cereal crop with variability\n\n\nCode\n## Imports\n\n# from installed packages\nfrom random import *\n\n# from openalea.archicrop\nfrom openalea.archicrop.stand import agronomic_plot\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating a random cereal crop from descritive parameters with variability \n# Fix a seed\n#seed(1)\n\n# Initialize the list of plants\nplants_in_crop=[]\n\n# Fixed parameters for all plants\nlength_plot=5\nwidth_plot=5\nsowing_density=10\nplant_density=5\ninter_row=0.5\nnplants, positions, domain, domain_area, unit = agronomic_plot(length_plot, \n                                                               width_plot, \n                                                               sowing_density,  \n                                                               inter_row, \n                                                               noise=0.1)\n\n# For loop over all the plants in the crop\nfor n in range(nplants):\n    # Parameters varying among plants\n    height=150*(1+random()-0.5) \n    nb_phy=17\n    max_leaf_length=60*(1+random()-0.5)\n    insertion_angle=45*(1+random()-0.5)\n    scurv=0.7*(1+random()-0.5)\n    curvature=70*(1+random()-0.5)\n    phyllotactic_deviation=15*(1+random()-0.5)\n\n    # Functions calls\n    shoot, g_var = build_shoot(nb_phy=nb_phy, height=height, max_leaf_length=max_leaf_length, \n                                wl=0.1, diam_base=2.5, diam_top=1.0, \n                                insertion_angle=insertion_angle, scurv=scurv, curvature=curvature, \n                                alpha=-2.3, stem_q=1.1, rmax=0.7, skew=0.05,\n                                phyllotactic_angle=180, phyllotactic_deviation=phyllotactic_deviation, plant_orientation=45, spiral=True)\n\n    # Fill the list of plants\n    plants_in_crop.append(g_var)\n\n# Build and display scene\nscene_var, nump = build_scene(plants_in_crop, positions, leaf_material=Material(nice_green), stem_material=Material(nice_green))\n# display_scene(scene_var)\nPlantGL(scene_var)\n\n\n\n\n3.7.3 An intercrop organized in rows\n\n\nCode\n## Imports\n\n# from installed packages\nfrom openalea.plantgl.all import Material, Color3, Shape, Scene, Viewer, Translated, AxisRotated\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating an intercrop from descritive parameters\n\n# Fix a seed\nseed(1)\n\ndef plant(height, nb_phy, max_leaf_length, phyllotactic_angle):\n    \"\"\" return the MTG of a cereal shoot generative from descriptive parameters \"\"\"\n    \n    shoot, g = build_shoot(nb_phy=nb_phy, height=height, max_leaf_length=max_leaf_length, phyllotactic_angle=phyllotactic_angle, plant_orientation=45)\n    return g\n\n\n# Organize the plant mixture in alternate rows\nn_rows = 10\nlen_rows = 10\n\nd_inter = 70\nd_intra = 50\n\ndef plant_in_row(i):\n     if i%(4*d_inter)==0 or i%(4*d_inter)==d_inter: return plant(height=1700, nb_phy=18, max_leaf_length=100, phyllotactic_angle=137)\n     else: return plant(height=900, nb_phy=18, max_leaf_length=40, phyllotactic_angle=60)\n\n\nplants_in_intercrop = [plant_in_row(x) for x in range(0, n_rows*d_inter, d_inter) for y in range(0, len_rows*d_intra, d_intra)]\n\npositions=[(x,y,0) for x in range(0, n_rows*d_inter, d_inter) for y in range(0, len_rows*d_intra, d_intra)]\n\n# Build and display scene\nscene_ic, nump = build_scene(plants_in_intercrop, positions, leaf_material=Material(nice_green), stem_material=Material(nice_green))\n# display_scene(scene_ic)\nPlantGL(scene_ic)",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#tillering-branching",
    "href": "structural_cereal_model.html#tillering-branching",
    "title": "3  Structural cereal model",
    "section": "3.8 Tillering / Branching",
    "text": "3.8 Tillering / Branching\nFirst, basipetal tillers, straight, oriented according to a certain angle, appearing according to a certain timing\nParameters : number, maximal order, reduction factor, tiller appearance rate (&gt;1 phyllochron or not? several mechanisms depending on species, keep it simple at first), insertion angle (same as leaf ?), tiller curvature, condition related to density (ex: hyp sorghum im field –&gt; no tiller)\nFor the final structure: When visiting the phytomers from the base, the tillers will be allocated sequentially to the short internodes, following their age and, for a given age, following the ascending order of tiller order, in the limits of the total number of tillers and the maximal order allowed for tillers. Some geometrical features (length, stem diameter, max leaf length, etc.) will be reduced by a given reduction ratio (order-dependent ?). The angles of the tillers\nHow do we manage the leaves of the short internodes bearing tillers ? Do we consider them at all ?\nFor growth: the age (start_tt and end_tt) is determined by a tiller appearance rate, expressed as a function of the phyllochron (and the order ?)\nsee weberpenn Ecomeristem Evers Abichou",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "algo_leaf_growth.html",
    "href": "algo_leaf_growth.html",
    "title": "4  Algorithm for leaf growth",
    "section": "",
    "text": "4.1 \\(H_0\\): Linear leaf area growth\nImport test STICS data\nInputs: - number of phytomers \\(N_{phy}\\) - development parameters: phyllochron \\(\\phi\\), ligulochron \\(lig\\) - leaf area distribution in plant: \\(leaf\\_area = f(rank, params)\\) with \\(params = (r_{max}, skew)\\) - maximal plant leaf area \\(S_{max}\\)\nSteps: - Define number of phytomers\nnb_phy = 20\ndef dev(phyllochron, ligulochron, nb_phy):\n\n    for i in range(1,nb_phy+1):\n        start = (i-1) * phyllochron\n        end = start + ligulochron\n        plt.plot(np.linspace(start, end, 2), [i,i], color=\"g\")\n    \n    # plt.fill_between([end/2.1,end/2.1+25], 0, nb_phy, color=\"grey\", alpha=0.4)\n    plt.xlabel(\"Thermal time (°C.d)\")\n    plt.ylabel(\"Phytomer rank\")\n    plt.xlim(0,end)\n    plt.show()\n\ninteract(dev, phyllochron=IntSlider(min=30,max=60,step=5,value=45), ligulochron=IntSlider(min=50,max=100,step=5,value=80), nb_phy=fixed(nb_phy))\n\n\n\n\n&lt;function __main__.dev(phyllochron, ligulochron, nb_phy)&gt;\nrmax = 0.7\nskew = 0.0005\nSmax = 1\n\nleaf_areas = bell_shaped_dist(Smax, nb_phy, rmax, skew)\n\nplt.plot(range(1,len(leaf_areas)+1), leaf_areas, color=\"g\")\nplt.fill_between(range(1,len(leaf_areas)+1), [0]*len(leaf_areas), leaf_areas, color=\"g\", alpha=0.2)\nplt.ylim(0,max(leaf_areas)+0.005)\nplt.xlabel(\"Phytomer rank\")\nplt.ylabel(\"Normalized leaf area\")\nplt.text(rmax*nb_phy-1.5, max(leaf_areas)/2, '$S = 1$', fontsize = 15)\nplt.show()\nSmax = 4000\nscaled_leaf_areas = bell_shaped_dist(Smax, nb_phy, rmax, skew)\n\nplt.plot(range(1,len(scaled_leaf_areas)+1), scaled_leaf_areas, color=\"g\")\nplt.fill_between(range(1,len(scaled_leaf_areas)+1), [0]*len(scaled_leaf_areas), scaled_leaf_areas, color=\"g\", alpha=0.2)\nplt.ylim(0,max(scaled_leaf_areas)+10)\nplt.xlabel(\"Phytomer rank\")\nplt.ylabel(\"Scaled leaf area\")\nplt.text(rmax*nb_phy-2, max(scaled_leaf_areas)/2, '$S = S_{max}$', fontsize = 15)\nplt.show()\ndef linear_leaf_growth(phyllochron, ligulochron, nb_phy):\n\n    fig, ax1 = plt.subplots()\n\n    starts = []\n    ends = []\n\n    for i in range(nb_phy):\n        start = i * phyllochron\n        end = start + ligulochron\n        starts.append(start)\n        ends.append(end)\n        ax1.plot(np.linspace(start, end, 2), [0,scaled_leaf_areas[i]], color=\"g\")\n        ax1.text(end-4, scaled_leaf_areas[i]+3, f'{i+1}', fontsize = 10)\n\n    S = []\n    \n    for t in range(max(ends)):\n        sum_temp = 0\n        for i,(s,e) in enumerate(zip(starts,ends)):\n            if s &lt;= t &lt; e:\n                sum_temp += (t-s)/(e-s) * scaled_leaf_areas[i]\n            elif t &gt;= e:\n                sum_temp += scaled_leaf_areas[i]\n        S.append(sum_temp)                \n    \n   \n    ax1.set_xlabel(\"Thermal time (°C.d)\")\n    ax1.set_ylabel(\"Leaf area (cm²)\")\n    ax1.fill_between([end/1.95,end/1.95+25], 0, max(scaled_leaf_areas), color=\"grey\", alpha=0.4)\n             \n    ax2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis\n    \n    ax2.set_ylabel(\"Plant leaf area (cm²)\")\n    ax2.fill_between(range(len(S)), [0]*len(S), S, color=\"g\", alpha=0.2)\n    \n    fig.tight_layout()  # otherwise the right y-label is slightly clipped\n    plt.show()\n\ninteract(linear_leaf_growth, phyllochron=IntSlider(min=30,max=60,step=5,value=45), ligulochron=IntSlider(min=50,max=100,step=5,value=80), nb_phy=fixed(nb_phy))\n\n\n\n\n&lt;function __main__.linear_leaf_growth(phyllochron, ligulochron, nb_phy)&gt;\nOutputs: - Plant leaf area growth dynamics \\(\\forall t \\in [0,T], S_{plant}(t) = \\sum_{i=1}^{N_{phy, appeared}} s_i(t)\\)",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Algorithm for leaf growth</span>"
    ]
  },
  {
    "objectID": "algo_leaf_growth.html#h_0-linear-leaf-area-growth",
    "href": "algo_leaf_growth.html#h_0-linear-leaf-area-growth",
    "title": "4  Algorithm for leaf growth",
    "section": "",
    "text": "Define leaf development from appearance to ligulation\n\n\n\nDefine allometric law for relative leaf area as a function of phytomer rank\n\n\n\nScale the leaf areas according to the given maximal plant leaf area \\(S_{max}\\)\n\n\n\nAt each time step, knowing H0, add the leaf area increment of each growing organ to the sum of appeared leaf area.",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Algorithm for leaf growth</span>"
    ]
  },
  {
    "objectID": "algo_leaf_growth.html#h_1-given-s_constraintft-forall-t-in-0t-s_potentialt-geq-s_constraintt",
    "href": "algo_leaf_growth.html#h_1-given-s_constraintft-forall-t-in-0t-s_potentialt-geq-s_constraintt",
    "title": "4  Algorithm for leaf growth",
    "section": "4.2 \\(H_1\\): given \\(S_{constraint}=f(t)\\), \\(\\forall t \\in [0,T]\\), \\(S_{potential}(t) \\geq S_{constraint}(t)\\)",
    "text": "4.2 \\(H_1\\): given \\(S_{constraint}=f(t)\\), \\(\\forall t \\in [0,T]\\), \\(S_{potential}(t) \\geq S_{constraint}(t)\\)\nInputs: - number of phytomers \\(N_{phy}\\) - development parameters: phyllochron \\(\\phi\\), ligulochron \\(lig\\) - leaf area distribution in plant: \\(leaf\\_area = f(rank, params)\\) with \\(params = (r_{max}, skew)\\) - plant leaf area growth dynamics \\(S_{constraint}=f(t)\\), such that maximal plant leaf area \\(S_{max} = max(S_{constraint}(t))\\)\nSteps: - Define number of phytomers\n\nnb_phy = 20\n\n\nDefine leaf development from appearance to ligulation\n\n\ndef dev(phyllochron, ligulochron, nb_phy):\n\n    starts = []\n    ends = []\n    \n    for i in range(1,nb_phy+1):\n        start = (i-1) * phyllochron\n        end = start + ligulochron\n        starts.append(start)\n        ends.append(end)\n        plt.plot(np.linspace(start, end, 2), [i,i], color=\"g\")\n\n    nb_growing = []\n    for t in range(max(ends)):\n        nb_growing_temp = 0\n        for i,(s,e) in enumerate(zip(starts,ends)):\n            if s &lt;= t &lt; e:\n                nb_growing_temp += 1\n        nb_growing.append(nb_growing_temp) \n        \n    plt.fill_between(range(len(nb_growing)), [0]*len(nb_growing), nb_growing, color=\"g\", alpha=0.2)\n    plt.xlabel(\"Thermal time (°C.d)\")\n    plt.ylabel(\"Phytomer rank\")\n    plt.xlim(0,end)\n    plt.show()\n\ninteract(dev, phyllochron=IntSlider(min=30,max=60,step=5,value=45), ligulochron=IntSlider(min=50,max=100,step=5,value=80), nb_phy=fixed(nb_phy))\n\n\n\n\n&lt;function __main__.dev(phyllochron, ligulochron, nb_phy)&gt;\n\n\n\nDefine allometric law for relative leaf area as a function of phytomer rank\n\n\nrmax = 0.7\nskew = 0.0005\nSmax = 1\n\nleaf_areas = bell_shaped_dist(Smax, nb_phy, rmax, skew)\n\nplt.plot(np.linspace(0,1,20), leaf_areas, color=\"g\")\nplt.plot()\nplt.fill_between(np.linspace(0,1,20), [0]*len(leaf_areas), leaf_areas, color=\"g\", alpha=0.2)\n# plt.ylim(0,max(leaf_areas)+0.005)\nplt.xlabel(\"Normalized phytomer rank\")\nplt.ylabel(\"Normalized leaf area\")\nplt.text(rmax-0.09, max(leaf_areas)/2, '$S = 1$', fontsize = 15)\nplt.show()\n\n\n\n\n\n\n\n\n\nScale the leaf areas according to the given maximal plant leaf area \\(S_{max}\\), to obtain \\(s_{i, potential}\\) for each leaf \\(i\\).\n\n\nSmax = 4000\nscaled_leaf_areas = bell_shaped_dist(Smax, nb_phy, rmax, skew)\n\nplt.plot(range(1,len(scaled_leaf_areas)+1), scaled_leaf_areas, color=\"g\")\nplt.fill_between(range(1,len(scaled_leaf_areas)+1), [0]*len(scaled_leaf_areas), scaled_leaf_areas, color=\"g\", alpha=0.2)\nplt.ylim(0,max(scaled_leaf_areas)+10)\nplt.xlabel(\"Phytomer rank\")\nplt.ylabel(\"Scaled leaf area (cm²)\")\nplt.text(rmax*nb_phy-2, max(scaled_leaf_areas)/2, '$S = S_{max}$', fontsize = 15)\nplt.show()\n\n\n\n\n\n\n\n\nAt each time step, distribute the increment of given plant leaf area \\(\\frac{dS_{constraint}(t)}{dt}\\) among \\(g\\) growing leaves.\nLet’s consider \\(F(\\alpha_1 x_1,…,\\alpha_g x_g) = \\sum_{i=1}^{g} \\alpha_i x_i\\), where \\(\\sum_{i=1}^{g} \\alpha_i = 1\\) and \\(x_i = ds_i\\) or \\(dh_i\\)\n\\(H_{1.0}\\) : Equal distribution of the gain among all growing vegetative organs\nFor a growing leaf \\(i\\) among \\(g\\) growing leaves in a plant, given a plant leaf area increment \\(dS(t)\\) for the plant at time \\(t\\), the leaf area increment \\(ds_i(t)\\) is:\n\\(ds_i(t)=\\frac{dS(t)}{g}\\) with \\(\\alpha_1=\\dots=\\alpha_g=\\frac{1}{g}\\)\n\ndef equal_distribution(ds, g):\n    return [ds/g for i in range(g)]\n\n\\(H_{1.1}\\): Demand of leaf area proportionnal to final area\nFor a growing leaf \\(i\\) of potential leaf area \\(S_{i}^{max}\\) among \\(g\\) growing leaves in a plant, given a plant leaf area increment \\(dS(t)\\) for the plant at time \\(t\\), the leaf area increment \\(ds_i(t)\\) is:\n$ds_i(t)=i dS(t) $ such that ${i} =  $ and \\(\\sum^{g}_{i=1} \\alpha_{i} = 1\\)\n\ndef demand_related_distribution(ds, potential_areas_growing_leaves):\n    sum_areas_growing_leaves = sum(potential_areas_growing_leaves)\n    return [ds*pi/sum_areas_growing_leaves for pi in potential_areas_growing_leaves]\n\nds = 10\npotential_areas_growing_leaves = [5,8,6]\nprint(demand_related_distribution(ds, potential_areas_growing_leaves))\n\n[2.6315789473684212, 4.2105263157894735, 3.1578947368421053]\n\n\n\\(H_{1.2}\\): Partition of unity with Bernstein polynomials of degree \\(g-1\\):\n\\(\\alpha_{i, g−1}(x)= \\frac{(g−1)!}{i!(g−1−i)!} x^i (1−x)^{g−1−i}\\) such that \\(\\sum^{g−1}_{i=0} \\alpha_{i, g−1} (x) = 1, \\forall x \\in [0,1]\\)\nin progress\n\ndef bernstein_polynomials(n, x): # n = g-1\n    \"\"\"\n    Compute Bernstein polynomials of degree n at point x (in [0,1]).\n    Returns a list of coefficients for partition of unity.\n    \"\"\"\n    bernstein = []\n    for i in range(n + 1):\n        bin_coeff = math.comb(n, i)  # Binomial coefficient\n        bernstein.append(bin_coeff * (x**i) * ((1 - x)**(n - i)))\n    return bernstein\n\n\ndef partition_of_unity(x_fixed):\n    \"\"\"\n    \n    \"\"\"\n    # print(\"Bernstein Polynomials:\")\n    g_range = [2,3,4]\n    x_range = np.arange(0,1.1,0.1)\n    \n    fig, axes = plt.subplots(1,len(g_range), figsize=(12, 4))\n    \n    for g in g_range:\n        # print(f\"For {g} growing organs:\")\n        n = g - 1\n        values = {i: [] for i in range(1, g + 1)}\n        \n        for x in x_range:\n            bernstein = bernstein_polynomials(n, x)\n            for j,b in enumerate(bernstein):\n                values[j+1].append(round(b,5))\n            # print(f\"    - at point {round(x,1)}\", bernstein)\n    \n        for k,v in values.items():\n            axes[g-2].plot(x_range, v, color='green')\n            axes[g-2].text(x_fixed, v[int(x_fixed*10)], f\"{k}\")\n        axes[g-2].set_title(f\"For {g} growing organs\")\n        axes[g-2].plot([x_fixed]*2,[0,1], linestyle='--', color='gray')\n    \n    plt.suptitle(\"Partition of unity with Bernstein polynomials\")\n    plt.subplots_adjust(wspace=0.2)\n    plt.show()\n\ninteract(partition_of_unity, x_fixed=FloatSlider(min=0.0,max=1.0,step=0.1,value=0.3))\n\n\n\n\n&lt;function __main__.partition_of_unity(x_fixed)&gt;",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Algorithm for leaf growth</span>"
    ]
  },
  {
    "objectID": "algo_leaf_growth.html#from-leaf-area-increment-to-leaf-length-increment",
    "href": "algo_leaf_growth.html#from-leaf-area-increment-to-leaf-length-increment",
    "title": "4  Algorithm for leaf growth",
    "section": "4.3 From leaf area increment to leaf length increment",
    "text": "4.3 From leaf area increment to leaf length increment\nLeaf shape\n\nwl = 0.12\n\n\ndef sr_prevot(nb_segment=100, alpha=-2.3):\n    beta = -2 * (alpha + np.sqrt(-alpha))\n    gamma = 2 * np.sqrt(-alpha) + alpha\n    s = np.linspace(0, 1, nb_segment + 1)\n    r = alpha * s**2 + beta * s + gamma\n    return s, r\n\ndef leaf_elongation(l, dl):\n    sp, rp = sr_dornbush()\n    ss = int(l*100)\n    dss = int(dl*100)\n    plt.plot(sp, rp, color=\"g\")\n    plt.plot(sp, -rp, color=\"g\")\n    plt.plot(sp,[0]*len(rp), color=\"g\", linestyle=\"--\")\n    plt.fill_between(sp[-ss:], -rp[-ss:], rp[-ss:], color=\"g\", alpha=0.2)\n    plt.fill_between(sp[-(ss+dss):], -rp[-(ss+dss):], rp[-(ss+dss):], color=\"g\", alpha=0.2)\n    # plt.text(max(0,1-(l+dl))+0.03, 0.1, f\"dl = {round(min(dl,1.0-l),5)}\")\n    plt.xlabel(\"Normalized leaf length\")\n    plt.ylabel(\"Normalized leaf width\")\n    plt.show()\n\ninteract(leaf_elongation, l=FloatSlider(min=0.001,max=1.001,step=0.05,value=0.3), dl=FloatSlider(min=0.0,max=1.0,step=0.05,value=0.1))\n\n\n\n\n&lt;function __main__.leaf_elongation(l, dl)&gt;\n\n\nl = f(S) curve fitting\nWith Prevot leaf shape\n\nfrom scipy.integrate import cumulative_simpson\n\nl,p = sr_prevot()\np = p[::-1]\nS = cumulative_simpson(x=l, y=p, initial=0)\nS_norm = S / S[-1]\n\nplt.plot(l,p)\nplt.plot(l,S_norm)\nplt.show()\n\n\n\n\n\n\n\n\n\nfrom scipy.interpolate import splrep, splev\n\nt,c,k = splrep(x=S_norm, y=l, k=3, task=0)\n\ny = splev(x=S_norm, tck=(t,c,k))\n\nplt.plot(S_norm, y)\nplt.plot(l, S_norm)\nplt.show()\n\n\n\n\n\n\n\n\n\nS_t = 0.3\nprint(f\"For a surface of {S_t}, we get a leaf length of {round(float(splev(x=S_t, tck=(t,c,k))),4)}\")\n\nFor a surface of 0.3, we get a leaf length of 0.4362\n\n\nWith Dornbush leaf shape\n\nfrom openalea.archicrop.cereals_leaf import sr_dornbush\nfrom scipy.interpolate import splrep, splev\n\n# 100 pts\nl, p = sr_dornbush(nb_segment=100)\np = p[::-1]\nS = cumulative_simpson(x=l, y=p, initial=0)\nS_norm = S / S[-1]\n\nt,c,k = splrep(x=S_norm, y=l, k=3, task=0)\n\ny = splev(x=S_norm, tck=(t,c,k))\n\nS_t = 0.0001\nprint(f\"For a surface of {S_t}, we get a leaf length of {round(float(splev(x=S_t, tck=(t,c,k))),10)}\")\n\nplt.plot(l,p,'g', alpha=0.5)\nplt.plot(l,S_norm,'r', alpha=0.5)\nplt.plot(S_norm, y,'orange', alpha=0.5)\n\n# 1000 pts\n\nl_1000, p_1000 = sr_dornbush(nb_segment=1000)\np_1000 = p_1000[::-1]\nS_1000 = cumulative_simpson(x=l_1000, y=p_1000, initial=0)\nS_norm_1000 = S_1000 / S_1000[-1]\n\nt_1000,c_1000,k_1000 = splrep(x=S_norm_1000, y=l_1000, k=3, task=0)\n\ny_1000 = splev(x=S_norm_1000, tck=(t_1000,c_1000,k_1000))\n\nprint(f\"For a surface of {S_t}, we get a leaf length of {round(float(splev(x=S_t, tck=(t_1000,c_1000,k_1000))),10)}\")\n\nplt.plot(l_1000,p_1000,'g')\nplt.plot(l_1000,S_norm_1000,'r')\nplt.plot(S_norm_1000, y_1000,'orange')\n\ny_1000_to_100 = np.array([v for i,v in enumerate(y_1000) if i%10==0])\n\nplt.plot(S_norm, y_1000_to_100-y, 'b')\n\nprint(y_1000_to_100-y)\n\nplt.show()\n\nFor a surface of 0.0001, we get a leaf length of 0.0020990851\nFor a surface of 0.0001, we get a leaf length of 0.0015153033\n[ 2.31370477e-18  8.11804009e-03  7.93353918e-03  7.74903827e-03\n  7.56453736e-03  7.38003644e-03  7.19553553e-03  7.01103462e-03\n  6.82653371e-03  6.64203280e-03  6.45753189e-03  6.27303098e-03\n  6.08853007e-03  5.90402916e-03  5.71952824e-03  5.53502733e-03\n  5.35052642e-03  5.16602551e-03  4.98152460e-03  4.79702369e-03\n  4.61252278e-03  4.42802187e-03  4.24352096e-03  4.05902004e-03\n  3.87451913e-03  3.69001822e-03  3.50551731e-03  3.32101640e-03\n  3.13651549e-03  2.95201458e-03  2.76751367e-03  2.58301276e-03\n  2.39851184e-03  2.21401093e-03  2.02951002e-03  1.84500911e-03\n  1.66050820e-03  1.47600729e-03  1.29150638e-03  1.10700547e-03\n  9.22504556e-04  7.38003644e-04  5.53502733e-04  3.69001822e-04\n  1.84500911e-04  1.11022302e-16 -8.34851245e-05 -1.66970249e-04\n -2.50455373e-04 -3.33940498e-04 -4.17425622e-04 -5.00910747e-04\n -5.84395871e-04 -6.67880996e-04 -7.51366120e-04 -8.34851245e-04\n -9.18336369e-04 -1.00182149e-03 -1.08530662e-03 -1.16879174e-03\n -1.25227687e-03 -1.33576199e-03 -1.41924712e-03 -1.50273224e-03\n -1.58621736e-03 -1.66970249e-03 -1.75318761e-03 -1.83667274e-03\n -1.92015786e-03 -2.00364299e-03 -2.08712811e-03 -2.17061324e-03\n -2.25409836e-03 -2.33758349e-03 -2.42106861e-03 -2.50455373e-03\n -2.58803886e-03 -2.67152398e-03 -2.75500911e-03 -2.83849423e-03\n -2.92197936e-03 -3.00546448e-03 -3.08894961e-03 -3.17243473e-03\n -3.25591985e-03 -3.33940498e-03 -3.42289010e-03 -3.50637523e-03\n -3.58986035e-03 -3.67334548e-03 -3.75683060e-03 -3.84031573e-03\n -3.92380085e-03 -4.00728597e-03 -4.09077110e-03 -4.17425622e-03\n -4.25774135e-03 -4.34122647e-03 -4.42471160e-03 -4.50819672e-03\n  0.00000000e+00]\n\n\n\n\n\n\n\n\n\nAnalytical expression of leaf area as a function of midrib length from tip to base\n\n# Define the variable and parameters\ns = symbols('l')\nL, wl, alpha = symbols('L, wl, alpha') \n\n# Define the scaled leaf shape function with parameters\n# alpha = -2.3\nbeta = -2 * (alpha + sqrt(-alpha))\ngamma = 2 * sqrt(-alpha) + alpha\nr = wl * L * (alpha * (s/L)**2 + beta * (s/L) + gamma)\n\n# Reflect the function to the axis x=0.5 \nreflected_r = r.subs(s, -s+L).simplify()\n\n# Find the indefinite integral (primitive)\nprimitive_f = integrate(reflected_r, s)\n\nprint(2*primitive_f)\n\n2*l**2*wl*sqrt(-alpha) + 2*alpha*l**3*wl/(3*L)\n\n\n\ndef leaf_area(l, L=1, wl=1, alpha=-2.3):\n    return 2*l**2*wl*math.sqrt(-alpha) + 2*alpha*l**3*wl/(3*L)\n    \ndef d_leaf_area(l, dl, L=1, wl=1):\n    return leaf_area(l+dl,L,wl) - leaf_area(l,L,wl)\n\ndef d_leaf_area_norm(l, dl, L=1, wl=1):\n    return (leaf_area(l+dl,L,wl) - leaf_area(l,L,wl)) / leaf_area(L,L,wl)\n\nprint(\"Total leaf area :\", leaf_area(1, wl=0.12))\nprint(\"Delta leaf area in l=[0.5,0.6]\", d_leaf_area(0.5, 0.1, wl=0.12))\n\nTotal leaf area : 0.1799780213144744\nDelta leaf area in l=[0.5,0.6] 0.023293582344592154\n\n\n\nplt.plot(l_values, [leaf_area(value) for value in l_values], color=\"g\")\nplt.xlabel(\"Normalized leaf length l\")\nplt.ylabel(\"Discretized dS/dl\")\n\nplt.show()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[56], line 1\n----&gt; 1 plt.plot(l_values, [leaf_area(value) for value in l_values], color=\"g\")\n      2 plt.xlabel(\"Normalized leaf length l\")\n      3 plt.ylabel(\"Discretized dS/dl\")\n\nNameError: name 'l_values' is not defined\n\n\n\nDiscretizing leaf area to get dS-to-dl correspondance easily\n\nL = 1\nwl = 1\ndl = 0.05*L \nl_values = np.arange(0.0, L+dl, dl) \n\nds_list = [0.0]\nfor l in l_values[1:]:\n    ds_list.append(d_leaf_area(l,dl,L,wl))\nprint(ds_list)\nprint(np.sum(ds_list))\n\nfig, ax1 = plt.subplots()\n\nax1.bar(l_values, ds_list, width=dl, color=\"g\", alpha=0.4)\nax1.set_xlabel(\"Normalized leaf length l\")\nax1.set_ylabel(\"Discretized dS/dl\")\n         \nax2 = ax1.twinx()  \n\nax2.plot(l_values, np.cumsum(ds_list), color=\"g\")\nax2.set_ylabel(\"Cumulated sum of leaf area along midrib : S = w(l)\")\nax2.set_ylim(0,np.sum(ds_list))\n\nfig.tight_layout()  # otherwise the right y-label is slightly clipped\n\nplt.show()\n\n\nfrom scipy.optimize import fsolve\n\n# Define the area function A(l) as given\ndef A_l(l, alpha, wl, L):\n    return 2 * l**2 * wl * math.sqrt(-alpha) + (2 * alpha * l**3 * wl) / (3 * L)\n\n# Inverse function: finding l for a given A\ndef l_A_inverse(A, alpha, wl, L):\n    # Define the equation A(l) - A = 0 to solve\n    func = lambda l: A_l(l, alpha, wl, L) - A\n    # Use fsolve to numerically solve for l given A\n    l_guess = 0.5  # initial guess for fsolve\n    l_solution = fsolve(func, l_guess)[0]\n    return l_solution\n\n# Generate A values and compute corresponding l(A) values\nA_values = np.linspace(0, 1, 500)\nl_values_inverse = np.array([l_A_inverse(A, alpha, wl, L) for A in A_values])\n\n# Restrict l to the range [0, 1] and adjust the corresponding A values\nl_values_in_range = l_values_inverse[(l_values_inverse &gt;= 0) & (l_values_inverse &lt;= 1)]\nA_values_in_range = A_values[:len(l_values_in_range)]\n\n# Plot the results for l in the range [0, 1]\nplt.figure(figsize=(8, 6))\nplt.plot(A_values_in_range, l_values_in_range, label=\"l(A) within [0, 1]\", color=\"darkgreen\")\nplt.title(\"Plot of l(A) vs A (Restricted to l in [0, 1])\", fontsize=14)\nplt.xlabel(\"A (Area)\", fontsize=12)\nplt.ylabel(\"l (Length)\", fontsize=12)\nplt.grid(True)\nplt.legend()\nplt.show()\n\n\nfrom scipy.interpolate import BSpline, make_interp_spline, UnivariateSpline\n\nds_cumsum = np.cumsum(ds_list)\n\n# # Create a B-spline with degree k=2 (quadratic spline)\n# k = 3  # Degree of the spline\n# bspline = make_interp_spline(ds_cumsum, l_values, k=k)\n\n# # # Evaluate spline and approximate expressions\n# # l_new = bspline(ds_cumsum)\n\n# # Extract knots, coefficients, and degree\n# knots = bspline.t  # Knot vector\n# coefficients = bspline.c  # Spline coefficients\n# degree = bspline.k  # Degree of the spline\n\n# # Define symbolic variable\n# x = symbols('x')\n\n# # Generate the B-spline piecewise expression\n# piecewise_expr = []\n# for i in range(len(coefficients) - degree - 1):\n#     # Get the polynomial coefficients for the current interval\n#     basis_poly = BSpline.basis_element(knots[i:i+degree+2])\n#     piece_expr = sum(c * (x - knots[i])**j for j, c in enumerate(basis_poly.c))\n#     condition = (x &gt;= knots[i]) & (x &lt; knots[i + 1])\n#     piecewise_expr.append((piece_expr, condition))\n\n# # Combine into a symbolic piecewise expression\n# b_spline_expr = Piecewise(*piecewise_expr)\n# print(\"B-Spline Expression:\", b_spline_expr)\n\n\n\ncs_ds = CubicSpline(ds_cumsum, l_values, bc_type=\"natural\")\nl_interp = cs_ds(ds_cumsum)  \n\n# Define symbolic variable\nx = symbols('x')\npiecewise_expr = []\n\nfor i in range(len(ds_cumsum) - 1):\n    # Coefficients for the interval [x_points[i], x_points[i+1]]\n    c0, c1, c2, c3 = cs_ds.c[:, i]\n    xi = ds_cumsum[i]\n    poly = c0 + c1 * (x - xi) + c2 * (x - xi)**2 + c3 * (x - xi)**3\n    piecewise_expr.append((poly, (x &gt;= xi) & (x &lt; ds_cumsum[i + 1])))\n\n# Combine into a single Piecewise expression\nspline_expr = Piecewise(*piecewise_expr)\nprint(\"Spline expression:\", spline_expr)\n\n# plt.plot(ds_cumsum, [spline_expr.subs(x, ds) for ds in ds_cumsum], color=\"red\")\n\n# plt.scatter(ds_cumsum, l_values, color=\"g\")\n# plt.plot(ds_cumsum, basis_poly, color=\"black\")\nplt.plot(ds_cumsum, l_interp, color=\"black\")\n# plt.plot(ds_cumsum, poly, color=\"black\")\nplt.xlabel(\"Cumulated sum of leaf area along midrib : S = w(l)\")\nplt.ylabel(\"Normalized leaf length l\")\nplt.show()\n\n\ncorres_dl_dS = {}\nfor i,dl in enumerate(l_values):\n    corres_dl_dS[dl] = np.cumsum(ds_list)[i]\n# print(corres_dl_dS)\n\n\nl = 0\ndS_input = 0.02\n\ndef search_new_dl(d, l, dS_input, L=1):\n    found_start = False  \n    first = True\n    key_prev = None\n    value_prev = None\n    for key, value in d.items():\n        if key &gt;= l:\n            found_start = True  \n            if first:\n                S_start = value\n                key_prev, value_prev = key, value\n                first = False\n        if found_start:\n            # print(key, value-S_start)\n            if value-S_start &gt;= dS_input:  \n                return key_prev, value_prev \n            else:\n                key_prev, value_prev = key, value\n    return L, value  # if no match is found --&gt; finished\n\nresult = search_new_dl(corres_dl_dS, l, dS_input)\nprint(\"New l = \", round(result[0],4))\n\nWhole process for one leaf\n\nl = 0\nl_list = [l]\ndS_new_list = [0]\nfor dS_input in dy_dense:\n    l, dS_new = search_new_dl(corres_dl_dS, l, dS_input, L=3000)\n    l_list.append(l)\n    dS_new_list.append(dS_new)\n\n# plt.plot(l_list, dS_new_list, color=\"g\")\n# plt.show()\n\n\nplt.plot(x_dense, dS_new_list[:-1], color=\"g\")\nplt.plot(x_dense, y_dense, color=\"orange\")\nplt.show()\n\nFor several leaves\n\n# dev\n\n# for loop\n    # distribute among growing leaves\n    # for each growing leaf\n        # translate dS in dl (check potential size)\n\n# compare plant profiles of potential and constraint\n\n\nAnalytical resolution of dl (in progress)\n\n\nL = 1\ndS_range = np.arange(0.01,0.1,0.01)\nx = np.arange(0.05,1.05*L,0.05)\n\nfig, ax = plt.subplots(2,1)\n\nax[0].plot([0]+x, [3.03*l**2*wl - 1.53*l**3*wl/L for l in [0]+x], color=\"g\")\nax[0].set_ylabel(\"S = w(l)\")\nfor dS in dS_range:\n    ax[1].plot(x, [dS/(3.03*l**2*wl - 1.53*l**3*wl/L) for l in x])\nax[1].set_ylabel(\"dl ?\")\nax[1].set_xlabel(\"Leaf length l, from tip to base\")\nplt.show()\n\nfor l in x:\n    print(\"l :\", round(l,3), \"dl :\", round(dS/(3.03*l**2*wl - 1.53*l**3*wl/L),3))",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Algorithm for leaf growth</span>"
    ]
  },
  {
    "objectID": "light_inter.html",
    "href": "light_inter.html",
    "title": "5  Light interception with Caribu",
    "section": "",
    "text": "5.1 Retrieve STICS dynamics from file\nstics_output_file = 'mod_ssorghum.sti'\nsowing_density = 10\ninter_row = 0.4\nstics_output_data = retrieve_stics_dynamics_from_file(stics_output_file, sowing_density)\ntime = [value[\"Thermal time\"] for value in stics_output_data.values()]\nLA_stics = [value[\"Plant leaf area\"] for value in stics_output_data.values()]\nheight_stics = [value[\"Plant height\"] for value in stics_output_data.values()]\npar_stics = [value[\"Absorbed PAR\"] for value in stics_output_data.values()]\nheight_potential_plant = max(height_stics)",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "light_inter.html#vary-chosen-architectural-and-developmental-parameters-and-select-the-sets-of-parameters-that-make-the-model-fit",
    "href": "light_inter.html#vary-chosen-architectural-and-developmental-parameters-and-select-the-sets-of-parameters-that-make-the-model-fit",
    "title": "5  Light interception with Caribu",
    "section": "5.2 Vary chosen architectural and developmental parameters and select the sets of parameters that make the model fit",
    "text": "5.2 Vary chosen architectural and developmental parameters and select the sets of parameters that make the model fit\n\n# Define parameter bounds \n# For sorghum\narchi_params = dict(\n    nb_phy = [10,30], # [10,15,20,25,30], \n    max_leaf_length = [50,120], \n    wl = [0.1,0.12], \n    diam_base = 2.2, \n    diam_top = 1.5, \n    insertion_angle = 30, # to vary for light interception\n    scurv = 0.7, # to vary for light interception\n    curvature = 90, # to vary for light interception\n    alpha = -2.3, \n    stem_q = [1.01,1.2], \n    rmax = [0.6,0.9], # 1-(1/3*(nb_phy - 5)/nb_phy) \n    skew = [0.01, 0.1], # 0.08 # 0.0005 \n    phyllotactic_angle = 180, \n    phyllotactic_deviation = 15, # to vary for light interception\n    phyllochron = [30,46],\n    plastochron = [30,46],\n    leaf_duration = [1,6],\n    stem_duration = [1,5],\n    leaf_senescence = [550, 900]\n)\n\n\n# Function to process parameters and generate samples\n# Generate parameter sets\nparam_sets = LHS_param_sampling(archi_params, n_samples=1000)\n\n\n# Select parameters sets for which the model fits the LAI and the height curves of the crop model, with a given error.\n\n# Start the timer\nstart_time = t.time()\n\nfitting_sim = params_for_curve_fit(param_sets, curves=stics_output_data, error_LA=200, error_height=20)\n\n# End the timer\nend_time = t.time()\n\n# Calculate elapsed time\nelapsed_time = (end_time - start_time)/60\nprint(f\"Elapsed time: {elapsed_time:.4f} minutes\")\n\nElapsed time: 43.0187 minutes\n\n\n\n# Create a figure with two subplots side by side\nfig, axes = plt.subplots(1, 2, figsize=(12, 6))  # 1 row, 2 columns\n\n# Plot on the first subplot\naxes[0].plot(time, LA_stics, color=\"black\", label=\"LA STICS\")\nfor result in fitting_sim['LA']:\n    axes[0].plot(time, result)\naxes[0].set_xlabel(\"Thermal time (°C.day)\")\naxes[0].set_ylabel(\"Leaf Area / plant\")\naxes[0].set_title(\"Leaf Area: 3D canopy vs. STICS\")\naxes[0].legend()\n\n# Plot on the second subplot\naxes[1].plot(time, height_stics, color=\"black\", label=\"height STICS\")\nfor result in fitting_sim['height']:\n    axes[1].plot(time, result)\naxes[1].set_xlabel(\"Thermal time (°C.day)\")\naxes[1].set_ylabel(\"Plant height\")\naxes[1].set_title(\"Plant height: 3D canopy vs. STICS\")\naxes[1].legend()\n\n# Adjust layout\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\ngood_params = fitting_sim['params']\ngood_params\n\n[{'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 11,\n  'max_leaf_length': 99.38953022234557,\n  'wl': 0.10669701997307109,\n  'stem_q': 1.1930546737497694,\n  'rmax': 0.7975932479443661,\n  'skew': 0.07599447227024302,\n  'phyllochron': 40.10762088180296,\n  'plastochron': 43.734086882182844,\n  'leaf_duration': 3.745165180939094,\n  'stem_duration': 2.6693719793972353,\n  'leaf_senescence': 616.4863456859163},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 13,\n  'max_leaf_length': 118.1105694869254,\n  'wl': 0.1093480966460198,\n  'stem_q': 1.1497200137218366,\n  'rmax': 0.8416458176468843,\n  'skew': 0.08228427264284736,\n  'phyllochron': 32.493791911914386,\n  'plastochron': 43.56492110137314,\n  'leaf_duration': 1.2016372244702727,\n  'stem_duration': 3.734316120177147,\n  'leaf_senescence': 650.8653645051161},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 11,\n  'max_leaf_length': 103.48584641182546,\n  'wl': 0.10890929549672723,\n  'stem_q': 1.1924904198138533,\n  'rmax': 0.801533870017076,\n  'skew': 0.08867506888742169,\n  'phyllochron': 36.625128549162646,\n  'plastochron': 42.20800198334537,\n  'leaf_duration': 3.734386676241516,\n  'stem_duration': 4.004192887644081,\n  'leaf_senescence': 564.3730219089649},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 10,\n  'max_leaf_length': 92.22268298824724,\n  'wl': 0.11091366426887748,\n  'stem_q': 1.1433860724719365,\n  'rmax': 0.771433756797771,\n  'skew': 0.047435526778279426,\n  'phyllochron': 44.45272651404066,\n  'plastochron': 39.471730874055595,\n  'leaf_duration': 5.4802652177158215,\n  'stem_duration': 2.7834247369680067,\n  'leaf_senescence': 658.8409166865579},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 11,\n  'max_leaf_length': 92.73439315497939,\n  'wl': 0.11604108071175104,\n  'stem_q': 1.0289385173595034,\n  'rmax': 0.6177958466512076,\n  'skew': 0.07019892739534422,\n  'phyllochron': 41.49646808670554,\n  'plastochron': 44.45599073202125,\n  'leaf_duration': 5.382455026500954,\n  'stem_duration': 2.5677463031300007,\n  'leaf_senescence': 653.1045778015482},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 14,\n  'max_leaf_length': 92.83961596578551,\n  'wl': 0.10031167052371445,\n  'stem_q': 1.0590545596113439,\n  'rmax': 0.7527045964023171,\n  'skew': 0.02256555190068299,\n  'phyllochron': 37.59576025447681,\n  'plastochron': 34.21382895687567,\n  'leaf_duration': 3.900290737357563,\n  'stem_duration': 2.8780297055204076,\n  'leaf_senescence': 871.8843364675288},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 12,\n  'max_leaf_length': 88.89606058255535,\n  'wl': 0.11062711435124575,\n  'stem_q': 1.1166192931631107,\n  'rmax': 0.8666496205283223,\n  'skew': 0.07490959075445477,\n  'phyllochron': 35.88509350615921,\n  'plastochron': 39.37937887515632,\n  'leaf_duration': 3.9150978252799193,\n  'stem_duration': 3.68072729459966,\n  'leaf_senescence': 767.1221147790122},\n {'diam_base': 2.2,\n  'diam_top': 1.5,\n  'insertion_angle': 30,\n  'scurv': 0.7,\n  'curvature': 90,\n  'alpha': -2.3,\n  'phyllotactic_angle': 180,\n  'phyllotactic_deviation': 15,\n  'nb_phy': 15,\n  'max_leaf_length': 105.71012584433498,\n  'wl': 0.11194957780559224,\n  'stem_q': 1.1540239470422693,\n  'rmax': 0.849411118397879,\n  'skew': 0.08984296774162541,\n  'phyllochron': 33.12704026193683,\n  'plastochron': 43.30263510500918,\n  'leaf_duration': 2.021267804677813,\n  'stem_duration': 2.5302271765651745,\n  'leaf_senescence': 863.974465040651}]\n\n\n\n# Align `good_params` to `archi_params` order\naligned_good_params = [{key: p[key] for key in archi_params.keys()} for p in good_params]\n\n# Initialize dictionaries for min and max values\nmin_values = {}\nmax_values = {}\n\n# Calculate min and max for each parameter\nfor key in archi_params.keys():\n    if isinstance(archi_params[key], list):  # Only for list parameters\n        # Extract values for this key across all good_params\n        values = [p[key] for p in aligned_good_params]\n        min_values[key] = min(values)\n        max_values[key] = max(values)\n\n# Update `archi_params` with min and max for list parameters\nfor key, value in archi_params.items():\n    if isinstance(value, list):  # Only update list parameters\n        archi_params[key] = [min_values[key], max_values[key]]\n        print(f\"{key}: {[round(val, 3) for val in archi_params[key]]}\")\n\n# Ensure all parameters in `archi_params` are lists\ndef to_list(d):\n    return {k: (v if isinstance(v, list) else [v]) for k, v in d.items()}\n\narchi_params = to_list(archi_params)\n\n# Display updated `archi_params`\nprint(\"Updated archi_params:\", archi_params)\n\nnb_phy: [10, 15]\nmax_leaf_length: [88.896, 118.111]\nwl: [0.1, 0.116]\nstem_q: [1.029, 1.193]\nrmax: [0.618, 0.867]\nskew: [0.023, 0.09]\nphyllochron: [32.494, 44.453]\nplastochron: [34.214, 44.456]\nleaf_duration: [1.202, 5.48]\nstem_duration: [2.53, 4.004]\nleaf_senescence: [564.373, 871.884]\nUpdated archi_params: {'nb_phy': [10, 15], 'max_leaf_length': [88.89606058255535, 118.1105694869254], 'wl': [0.10031167052371445, 0.11604108071175104], 'diam_base': [2.2], 'diam_top': [1.5], 'insertion_angle': [30], 'scurv': [0.7], 'curvature': [90], 'alpha': [-2.3], 'stem_q': [1.0289385173595034, 1.1930546737497694], 'rmax': [0.6177958466512076, 0.8666496205283223], 'skew': [0.02256555190068299, 0.08984296774162541], 'phyllotactic_angle': [180], 'phyllotactic_deviation': [15], 'phyllochron': [32.493791911914386, 44.45272651404066], 'plastochron': [34.21382895687567, 44.45599073202125], 'leaf_duration': [1.2016372244702727, 5.4802652177158215], 'stem_duration': [2.5302271765651745, 4.004192887644081], 'leaf_senescence': [564.3730219089649, 871.8843364675288]}\n\n\n\n\n################# in function ##################\n\n# Visualize the plants with these parameters\n\nfrom ipywidgets import interact, interactive, IntSlider, FloatSlider, fixed, Play, HBox, VBox, jslink\n\n# Fix a seed\nseed(100)\nnice_green = Color3((50, 100, 0))\n\n# slider on parameters with ranges, others fixed \n\nheight=height_potential_plant\nnb_phy_slider=IntSlider(min=min(archi_params[\"nb_phy\"]), max=max(archi_params[\"nb_phy\"]), step=1, value=15, description=\"Nb of phytomers\")\nmax_leaf_length_slider=IntSlider(min=min(archi_params[\"max_leaf_length\"]), max=max(archi_params[\"max_leaf_length\"]), step=1, value=50, description=\"Length of longest leaf\")\nwl_slider=FloatSlider(min=min(archi_params[\"wl\"]), max=max(archi_params[\"wl\"]), step=0.01, value=0.12)\ndiam_base_slider=fixed(archi_params[\"diam_base\"][0])\ndiam_top_slider=fixed(archi_params[\"diam_top\"][0])\ninsertion_angle_slider=IntSlider(min=min(archi_params[\"insertion_angle\"]), max=max(archi_params[\"insertion_angle\"]), step=1, value=30)\nscurv_slider=FloatSlider(min=min(archi_params[\"scurv\"]), max=max(archi_params[\"scurv\"]), step=0.01, value=0.7)\ncurvature_slider=IntSlider(min=min(archi_params[\"curvature\"]), max=max(archi_params[\"curvature\"]), step=5, value=90)\nalpha_slider=fixed(archi_params[\"alpha\"][0])\nstem_q_slider=fixed(archi_params[\"stem_q\"][0])\nrmax_slider=FloatSlider(min=min(archi_params[\"rmax\"]), max=max(archi_params[\"rmax\"]), step=0.01, value=0.8)\nskew_slider=fixed(archi_params[\"skew\"][0])\nphyllotactic_angle_slider=fixed(archi_params[\"phyllotactic_angle\"][0])\nphyllotactic_deviation_slider=IntSlider(min=min(archi_params[\"phyllotactic_deviation\"]), max=max(archi_params[\"phyllotactic_deviation\"]), step=5, value=15)\nphyllochron_slider=IntSlider(min=min(archi_params[\"phyllochron\"]), max=max(archi_params[\"phyllochron\"]), step=1, value=55)\nplastochron_slider=IntSlider(min=min(archi_params[\"plastochron\"]), max=max(archi_params[\"plastochron\"]), step=1, value=40)\nleaf_duration_slider=FloatSlider(min=min(archi_params[\"leaf_duration\"]), max=max(archi_params[\"leaf_duration\"]), step=0.1, value=3)\nstem_duration_slider=FloatSlider(min=min(archi_params[\"stem_duration\"]), max=max(archi_params[\"stem_duration\"]), step=0.1, value=2)\nleaf_senescence_slider=IntSlider(min=min(archi_params[\"leaf_senescence\"]), max=max(archi_params[\"leaf_senescence\"]), step=10, value=800)\n\ntime_slider = IntSlider(value=0, min=0, max=len(time), step=1, description=\"Time\")\n\n# Interactive widget setup\nplay_widget = Play(value=0, min=0, max=len(time), step=1, interval=1000)\n\n# Link play widget with time slider\njslink((play_widget, 'value'), (time_slider, 'value'))\n\n# Callback to update scene\ndef update_scene(*args):\n    seed(100)\n    sorghum = ArchiCrop(height, nb_phy_slider.value, max_leaf_length_slider.value, wl_slider.value, \n                        diam_base_slider.value, diam_top_slider.value, insertion_angle_slider.value, scurv_slider.value, \n                        curvature_slider.value, alpha_slider.value, stem_q_slider.value, rmax_slider.value, skew_slider.value, \n                        phyllotactic_angle_slider.value, phyllotactic_deviation_slider.value, \n                        phyllochron_slider.value, plastochron_slider.value, leaf_duration_slider.value, \n                        stem_duration_slider.value, leaf_senescence_slider.value)\n    sorghum.generate_potential_plant()\n    sorghum.define_development()\n    growing_plant = sorghum.grow_plant(stics_output_data)\n    growing_plant_mtg = list(growing_plant.values())\n    Viewer.display(build_scene(growing_plant_mtg[time_slider.value], leaf_material = Material(nice_green), stem_material=Material(nice_green))[0])\n\n# Attach update callback\nnb_phy_slider.observe(update_scene, names='value')\nmax_leaf_length_slider.observe(update_scene, names='value')\n# insertion_angle_slider.observe(update_scene, names='value')\n# scurv_slider.observe(update_scene, names='value')\n# curvature_slider.observe(update_scene, names='value')\ntime_slider.observe(update_scene, names='value')\n\n# Display widgets\ncontrols = VBox([nb_phy_slider, max_leaf_length_slider, insertion_angle_slider, scurv_slider, curvature_slider, HBox([time_slider, play_widget])])\ndisplay(controls)\n\n# Initial scene display\nupdate_scene()\n\n# cf github openalea weberpenn trunk_parameters\n\n\n\n\n\n# # Calculate covariance matrix\n# covariance_matrix = np.cov(parameters, rowvar=False)\n\n# # Calculate correlation matrix\n# correlation_matrix = np.corrcoef(parameters, rowvar=False)\n\n# # Display results\n# print(\"Covariance matrix:\\n\", covariance_matrix)\n# print(\"Correlation matrix:\\n\", correlation_matrix)\n\n\n# from sklearn.decomposition import PCA\n\n# # Perform PCA\n# pca = PCA()\n# pca.fit(parameters)\n\n# # Principal components and explained variance\n# print(\"Principal components:\\n\", pca.components_)\n# print(\"Explained variance ratio:\", pca.explained_variance_ratio_)\n\n\n# from sklearn.cluster import KMeans\n\n# # Perform clustering\n# num_clusters = 2  # Adjust as needed\n# kmeans = KMeans(n_clusters=num_clusters, random_state=42)\n# clusters = kmeans.fit_predict(parameters)\n\n# # Add cluster labels to parameter sets\n# print(\"Cluster labels:\", clusters)\n\n\n# import pandas as pd\n# import seaborn as sns\n\n# # Heatmap of correlation matrix\n# plt.figure(figsize=(10, 8))\n# sns.heatmap(correlation_matrix, annot=True, cmap=\"coolwarm\", fmt=\".2f\")\n# plt.title(\"Parameter Correlation Matrix\")\n# plt.show()",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "light_inter.html#within-this-space-of-possible-plant-architectures-regarding-parameters-affecting-plant-leaf-area-and-height-throught-time-we-vary-parameters-related-to-the-orientation-of-the-leaves-in-space-and-to-crop-spatial-configuration.",
    "href": "light_inter.html#within-this-space-of-possible-plant-architectures-regarding-parameters-affecting-plant-leaf-area-and-height-throught-time-we-vary-parameters-related-to-the-orientation-of-the-leaves-in-space-and-to-crop-spatial-configuration.",
    "title": "5  Light interception with Caribu",
    "section": "5.3 Within this space of possible plant architectures regarding parameters affecting plant leaf area and height throught time, we vary parameters related to the orientation of the leaves in space and to crop spatial configuration.",
    "text": "5.3 Within this space of possible plant architectures regarding parameters affecting plant leaf area and height throught time, we vary parameters related to the orientation of the leaves in space and to crop spatial configuration.\n\nparams_to_vary_for_light_it = dict(\n    insertion_angle = [10,50],\n    scurv = [0.4,0.9],\n    curvature = [35,130],\n    phyllotactic_deviation = [0,45]\n)\n\ncrop_params = dict(\n    length_plot = 1, \n    width_plot = 1, \n    sowing_density = sowing_density, # [10, 28], \n    inter_row = [0.4, 0.8], # 0.4 for 10\n)\n\n\n# TO DO : vary parameters one by one, then together",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "light_inter.html#stand",
    "href": "light_inter.html#stand",
    "title": "5  Light interception with Caribu",
    "section": "5.4 Stand",
    "text": "5.4 Stand\n\nsorghum = ArchiCrop(height, **good_params[0])\n                    # nb_phy, max_leaf_length, wl, \n                    # diam_base, diam_top, insertion_angle, scurv, \n                    # curvature, alpha, stem_q, rmax, skew, \n                    # phyllotactic_angle, phyllotactic_deviation, \n                    # phyllochron, plastochron, leaf_duration, \n                    # stem_duration, leaf_senescence)\nsorghum.generate_potential_plant()\nscene = sorghum.display_stand(sowing_density=sowing_density, length_plot=1, width_plot=1, inter_row=0.4)\n\nPlantGL(scene)\n\n\n\n\n\n# Store scenes for MTG at all times\n\nsorghum.define_development()\ngrowing_plant = sorghum.grow_plant(stics_output_data)\n\nnplants, positions, domain, domain_area, unit = agronomic_plot(length=1, width=1, sowing_density=10, inter_row=0.4, noise=0.1)\n\nscenes = {}\n\nfor k,v in growing_plant.items():\n    scene, nump = build_scene([v]*nplants, positions, leaf_material=Material(nice_green), stem_material=Material(nice_green))\n    scenes[k] = scene",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "light_inter.html#compute-par-intercepted",
    "href": "light_inter.html#compute-par-intercepted",
    "title": "5  Light interception with Caribu",
    "section": "5.5 Compute PAR intercepted",
    "text": "5.5 Compute PAR intercepted\n\nnplants, positions, domain, domain_area, unit = agronomic_plot(length=1, width=1, sowing_density=10, inter_row=0.4, noise=0.1)\n\npar_caribu = []\n\nscenes = []\n\n# Start the timer\nstart_time = t.time()\n\nfor params in good_params:\n    sorghum = ArchiCrop(height, **params)\n    sorghum.generate_potential_plant()\n    sorghum.define_development()\n    growing_plant = sorghum.grow_plant(stics_output_data)\n\n    scenes_temp = {}\n    for k,v in growing_plant.items():\n        scene, nump = build_scene([v]*nplants, positions, leaf_material=Material(nice_green), stem_material=Material(nice_green))\n        scenes_temp[k] = scene\n    scenes.append(scenes_temp)\n    \n    par_caribu_temp = []\n    for scene in scenes_temp.values():\n        par_caribu_temp.append(compute_light_inter(scene))\n    par_caribu.append(par_caribu_temp)\n\n# End the timer\nend_time = t.time()\n\n# Calculate elapsed time\nelapsed_time = (end_time - start_time)/60\nprint(f\"Elapsed time: {elapsed_time:.4f} minutes\")\n\nElapsed time: 20.7545 minutes\n\n\n\n# Convert to a NumPy array for easier manipulation\nfor i,par in enumerate(par_caribu):\n    for j,p in enumerate(par):\n        par_caribu[i][j] /= 10\ncurves = par_caribu\ncurves_array = np.array(curves)\n\n# Calculate the envelope: min and max values for each time point\nmin_values = curves_array.min(axis=0)\nmax_values = curves_array.max(axis=0)\n\n# Plotting the envelope along with individual curves for context\ntime_points = time\nfor curve in curves:\n    plt.plot(time_points, curve, alpha=0.5, linestyle='--')  # Plot each curve (optional for visualization)\n\nplt.fill_between(time_points, min_values, max_values, color=\"skyblue\", alpha=0.4)\nplt.plot(time_points, min_values, color=\"blue\", linestyle=\"--\", label=\"Min 3D\")\nplt.plot(time_points, max_values, color=\"red\", linestyle=\"--\", label=\"Max 3D\")\nplt.plot(time_points, par_stics, color=\"black\", label=\"STICS\")\n# plt.scatter(time_points, LA_stics)\n\n# Labels and legend\nplt.xlabel(\"Thermal time\")\nplt.ylabel(\"% of absorbed PAR\")\nplt.title(\"Absorbed PAR: 3D canopy vs. STICS\")\nplt.legend()\nplt.show()",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "light_inter.html#compute-beer-lambert-light-extinction-coefficient-at-each-time-step",
    "href": "light_inter.html#compute-beer-lambert-light-extinction-coefficient-at-each-time-step",
    "title": "5  Light interception with Caribu",
    "section": "5.6 Compute Beer-Lambert light extinction coefficient at each time step",
    "text": "5.6 Compute Beer-Lambert light extinction coefficient at each time step\n\n5.6.1 Light interception in STICS\nThe radiation intercepted by the crop \\(raint\\) is expressed according to a Beer’s law function of \\(lai\\). The \\(extinP\\) parameter is a daily extinction coefficient and \\(parsurrgG\\) is a climatic parameter corresponding to the ratio (in radiative energy) of photosynthetically active radiation to the global radiation \\(trg(t)\\) (around 0.48, Varlet-Grancher et al. (1982)).\n\\[raint(t)=0.95*parsurrgG*trg(t)*(1−exp^{−extinP*(lai(t)+eai(t))})\\]\n\\[extinP = - \\frac{1}{lai(t)+eai(t)} ln(1 - \\frac{raint(t)}{0.95*parsurrgG*trg(t)})\\]\n\\[extinP = - \\frac{1}{lai(t)+eai(t)} ln(1 - ratio\\_par\\_abs)\\]\nextin_stics = 0.7\n\n# Compute coef extinP\n\nextinP_list = []\n\nfor par_time_series in par_caribu:\n    extinP_per_sim = []\n    for i,par in enumerate(par_time_series):\n        if par &lt; 1:\n            lai = LAI_stics[i]*sowing_density/10000 \n            extinP = -1/lai * math.log(1-par)\n        else:\n            extinP = 1\n        extinP_per_sim.append(extinP)\n    extinP_list.append(extinP_per_sim)\n\ntime_points = time[1:]\nfor curve in extinP_list:\n    plt.plot(time_points, curve, alpha=0.5, linestyle='-')\nplt.show()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[20], line 9\n      7 for i,par in enumerate(par_time_series):\n      8     if par &lt; 1:\n----&gt; 9         lai = LAI_stics[i]*sowing_density/10000 \n     10         extinP = -1/lai * math.log(1-par)\n     11     else:\n\nNameError: name 'LAI_stics' is not defined\n\n\n\n\n# courbe parameters beer-lambert --&gt; analysis of decomposition of uncertainty, parametric",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "light_inter.html#next-steps",
    "href": "light_inter.html#next-steps",
    "title": "5  Light interception with Caribu",
    "section": "5.7 Next steps",
    "text": "5.7 Next steps\n\nSimulations to run with IFB Cloud",
    "crumbs": [
      "First chapter: Analyzing accuracy of formalisms in crop model when adding shoot structural variability",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Light interception with Caribu</span>"
    ]
  },
  {
    "objectID": "year_2.html",
    "href": "year_2.html",
    "title": "Second chapter : Analyzing accuracy of formalisms in crop model when adding root structural variability",
    "section": "",
    "text": "Analysis - root : Would considering root structure in an intercropping system be relevant for crop models ?\nHypothesis: The error of crop models, when it comes to modeling intercrops, are mainly due to the average plant hypothesis and the non-consideration of the plant root architecture.\nCreate a dynamic root FSPM for all 4 plants (cf lit), that enables to constrain root growth with density=f(depth) from STICS, in STICS’ 1D soil.\nImplement well-known structural reactions to stresses.\nRun simulations with both FSPM and STICS (stressless and stressed conditions : Vezy et al., 2023; Traore et al., 2022, 2023), varying (define variations ranges) when possible: root structures, spatial arrangement (with all same plants or all different to separate effects), env/stresses (N, water, light)\nFrom outputs from my models and from STICS for given processes and given conditions:\nCompare means and analyze variance of chosen output variables: water and N uptake, N fixing, etc.\nAnalyse uncertainty propagation in simulations; expected results: see which processes (integrated in root density) are the most impacted by the uncertainty in STICS’ root density.\nAnalyse sensitivity of some plant processes to structural variability (and spatial heterogeneity). Expected results: spot parameters of interest to implement in STICS as a parameter or different equation.\nCouple shoot and root models (when ?)\nCollaboration with post-doc from WUR, Jie Lu",
    "crumbs": [
      "Second chapter : Analyzing accuracy of formalisms in crop model when adding root structural variability"
    ]
  },
  {
    "objectID": "intro_2.html",
    "href": "intro_2.html",
    "title": "6  Introduction",
    "section": "",
    "text": "In progress …",
    "crumbs": [
      "Second chapter : Analyzing accuracy of formalisms in crop model when adding root structural variability",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "year_3.html",
    "href": "year_3.html",
    "title": "Third chapter: Improving STICS",
    "section": "",
    "text": "Modeling : How to model intercrops more accurately at crop scale, considering spatial issues when needed ?\nHypothesis: New crop models formalisms created through a multiscale approach would enable a better accuracy of the crop models.\nWhich formalisms would enable to translate spatial and structural considerations for chosen plant processes in a crop model ?\nFor each plant process targeted previously:\n- Develop formalisms to implement in STICS, by any appropriate method.\n- Run simulations and compare with simulations with previous version and with field data, to make sure new version of STICS fits data even better. (see with Mathilde de Freitas ?)",
    "crumbs": [
      "Third chapter: Improving STICS"
    ]
  },
  {
    "objectID": "intro_3.html",
    "href": "intro_3.html",
    "title": "7  Introduction",
    "section": "",
    "text": "In progress …",
    "crumbs": [
      "Third chapter: Improving STICS",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Introduction</span>"
    ]
  }
]